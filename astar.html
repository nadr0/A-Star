<head>
    
    <script type="text/javascript" src="class.js"></script>
    <script type="text/javascript" src="Node.js"></script>
    
    </head>
    <body>
      <canvas id="myCanvas" width="1050" height="600" style="border:1px solid #000099; padding-left: 0; padding-right: 0; margin-left: auto; margin-right: auto; display: block; background-color:0099FF; "></canvas>
      <script>

            window.requestAnimFrame = (function(callback) {
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
            function(callback) {
              window.setTimeout(callback, 1000 / 60);
            };
          })();

        var lastTime = Date.now();

        var debug = true;

        var canvas = document.getElementById('myCanvas');
        var context = canvas.getContext('2d');

        var openList = [];
        var closedList = [];
        var finalPath = [];

        var checkingNode = null;
        var startNode = null;
        var targetNode = null;
        var moveCost = 10;
        var targetFound = false;
        var sizeOfTile = 25;
        var allNodes = [];
        var data = new Array(canvas.height/sizeOfTile);
        var counter = 0;

        function fillAllNodes(){

          for (var i = 0; i < canvas.height/sizeOfTile; i++) {
            for (var j = 0; j < canvas.width/sizeOfTile; j++) { 
              data[i] = new Array(canvas.width/sizeOfTile);
            };
          };


          for (var i = 0; i < canvas.height/sizeOfTile; i++) {
            for (var j = 0; j < canvas.width/sizeOfTile; j++) {
              data[i][j] = new Node(j*25, i*25);
              allNodes.push(data[i][j]);
            };
          };

        };

        fillAllNodes();
        findAdjacentNodes();

        startNode = allNodes[870];
        checkingNode = startNode;
        targetNode = allNodes[25];

        CacluateHueristics();

        function drawAllNodes(){
          for (var i = 0; i < canvas.height/sizeOfTile; i++) {
            for (var j = 0; j < canvas.width/sizeOfTile; j++) {
              data[i][j].Update();
            };
          };

        };


        function DrawGrid(){

          var FillStyle = 'Blue';

          for (var i = 0; i < 42; i++) {
            context.beginPath();
            context.fillStyle = FillStyle;
            context.moveTo(25*i,0);
            context.lineTo(25*i,600);
            context.stroke();
            context.closePath();
            };

          for (var i = 0; i < 25; i++) {
            context.beginPath();
            context.fillStyle = FillStyle;
            context.moveTo(0, 25 * i);
            context.lineTo(1050, 25 * i);
            context.stroke();
            context.closePath();
          };
        }

        function animate(canvas, context,startTime) {
            var time = (new Date()).getTime() - startTime;
            var currentTime = Date.now();

            context.clearRect(0, 0, canvas.width, canvas.height);
            // UPDATE STARTS

            drawAllNodes();

            // Draws the grids for the nodes
            DrawGrid();

            if(!targetFound){
              findPath();
            }

            if(targetFound){
              targetNode.fillStyle = 'red';
              targetNode.parentNode.fillStyle = 'white';
              startNode.fillStyle = 'Blue';
              // traceBackPath();
            }


            if(debug){
              // drawToScreen();
            }

            requestAnimFrame(function() {
              animate(canvas, context, startTime);
            });
        }


        function findPath(){
          if(!targetFound){
            if(checkingNode.northNode){
              adjacentNode(checkingNode, checkingNode.northNode);
            }

            if(checkingNode.southNode){
              adjacentNode(checkingNode, checkingNode.southNode);
            }

            if(checkingNode.westNode){
              adjacentNode(checkingNode, checkingNode.westNode);
            }

            if(checkingNode.eastNode){
              adjacentNode(checkingNode, checkingNode.eastNode);
            }
          }

          if(!targetFound){
            addToCloseList(checkingNode);
            removeFromOpenList(checkingNode);

            checkingNode = getSmallestFValueNode();
          }


        };

        function adjacentNode(currentNode, testingNode){
          if(!testingNode){
            return;
          }

          if(testingNode === targetNode){
            targetNode.parentNode = currentNode;
            targetFound = true;
            return;
          }

          if(!checkClosedList(testingNode)){
            if(checkOpenList(testingNode)){
              var newGCost = currentNode.g + moveCost;
              if(newGCost < testingNode.g){
                testingNode.parentNode = currentNode;
                testingNode.g = newGCost;
                testingNode.calculateFValue();
              }
            }else{
              testingNode.parentNode = currentNode;
              testingNode.g = currentNode.g + moveCost;
              testingNode.calculateFValue();
              addToOpenList(testingNode);
            }
          }

        };
             
        function checkClosedList(testing){
          for (var i = 0; i < closedList.length; i++) {
            if(testing === closedList[i]){
              return true;
            }
          };
          return false;
        };

        function checkOpenList(testing){
          for (var i = 0; i < openList.length; i++) {
            if(testing === openList[i]){
              return true;
            }
          };
          return false;
        };

        function addToOpenList(node){
          openList.push(node);
        };

        function addToCloseList(node){
          node.fillStyle = 'Cyan';
          closedList.push(node)
        };

        function removeFromOpenList(node){
          var index = openList.indexOf(node);
          openList.splice(index, 1);
        };

        function getSmallestFValueNode(){
          var returnNode = openList[0];
          var lowestFValue = openList[0].f;

          for (var i = 0; i < openList.length; i++) {
            if(openList[i].f < lowestFValue){
              lowestFValue = openList[i].f;
              returnNode = openList[i];
            }
          };
          return returnNode;
        };

        function CacluateHueristics(){
          for (var i = 0; i < allNodes.length; i++) {
            var hueristic = 10 * (  Math.abs(allNodes[i].pos.x - targetNode.pos.x) + Math.abs(allNodes[i].pos.y - targetNode.pos.y)   );
            allNodes[i].h = hueristic;
          };
        };

        function findAdjacentNodes(){

          for (var i = 0; i < allNodes.length; i++) {
              for (var w = 0; w < allNodes.length; w++) {
                  if(allNodes[i].pos.x + (sizeOfTile) === allNodes[w].pos.x && allNodes[i].pos.y === allNodes[w].pos.y){
                     allNodes[i].eastNode = allNodes[w];
                  }
                  if(allNodes[i].pos.x - (sizeOfTile) === allNodes[w].pos.x && allNodes[i].pos.y === allNodes[w].pos.y){
                      allNodes[i].westNode = allNodes[w];
                  }
                  if(allNodes[i].pos.x === allNodes[w].pos.x && allNodes[i].pos.y + sizeOfTile === allNodes[w].pos.y){
                      allNodes[i].southNode = allNodes[w];
                  }
                  if(allNodes[i].pos.x === allNodes[w].pos.x && allNodes[i].pos.y - sizeOfTile === allNodes[w].pos.y){
                      allNodes[i].northNode = allNodes[w];
                  }
              };
          };

        };

        function drawToScreen(){
          context.fillStyle = 'black';
          for (var i = 0; i < allNodes.length; i++) {
            context.fillText(allNodes[i].h, allNodes[i].pos.x, allNodes[i].pos.y + allNodes[i].height/2);
          };
        }

        setTimeout(function() {
            var startTime = (new Date()).getTime();
            animate(canvas, context,startTime);
          }, 1000);
      </script>
</body> 