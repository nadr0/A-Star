<head>
    
    <script type="text/javascript" src="class.js"></script>
    <script type="text/javascript" src="Node.js"></script>
    <script type="text/javascript" src="pathfinder.js"></script>
    
    </head>
    <body>
      <canvas id="myCanvas" width="1920" height="960" style="border:1px solid #000000; padding-left: 0; padding-right: 0; margin-left: auto; margin-right: auto; display: block;  "></canvas>
      <script>

            window.requestAnimFrame = (function(callback) {
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
            function(callback) {
              window.setTimeout(callback, 1000 / 60);
            };
          })();

          var canvas = document.getElementById('myCanvas');
          var context = canvas.getContext('2d');
          var lastTime = Date.now();

          var mousePos = {x: null, y: null};

          var seek = true;

          var states = {pickingWalls: 'pickingWalls', pickingStartNode: 'pickingStartNode', pickingTargetNode: 'pickingTargetNode', findPath: 'findPath'};
          var currentState = states.pickingWalls;

          var pathfinder = new Pathfinder();

          var startPathFinding = false;

          var tilesize = 32;

          var isStartNodeCreated = false;
          var isTargetNodeCreated = false;


          pathfinder.fillNodeArrays();       
          pathfinder.findAdjacentNodes();
 

          pathfinder.drawNodes();

          function DrawGrid(){

            for (var i = 0; i < canvas.width/tilesize; i++) {
              context.beginPath();
              context.fillStyle = 'black';  
              context.moveTo(tilesize*i,0);
              context.lineTo(tilesize*i, canvas.height);
              context.stroke();
              context.closePath();
              };

            for (var i = 0; i < canvas.width/tilesize; i++) {
              context.beginPath();
              context.fillStyle = 'black';
              context.moveTo(0, tilesize * i);
              context.lineTo(canvas.width, tilesize * i);
              context.stroke();
              context.closePath();
            };
          }

          DrawGrid();

          function animate(canvas, context,startTime) {
              var time = (new Date()).getTime() - startTime;
              var currentTime = Date.now();

              context.clearRect(0, 0, canvas.width, canvas.height);
              
              pathfinder.drawNodes();
              DrawGrid();

              if(startPathFinding){
                if(!pathfinder.targetFound){
                    pathfinder.findPath();
                }

                if(pathfinder.targetFound && seek){
                  pathfinder.tracePathBack();
                  seek = false;
                }
              }
              
              requestAnimFrame(function() {
                animate(canvas, context, startTime);
              });
          }

          function getMousePos(canvas, evt) {
              var rect = canvas.getBoundingClientRect();
              return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
              };
          }

          canvas.addEventListener('mousemove', function(evt) {
                var mousepos = getMousePos(canvas, evt);
                mousePos.x = mousepos.x;
                mousePos.y = mousepos.y;
            }, false);


          document.onmousedown = function(event){
            //if(event.keyCode == '65'){PlayerOne.LeftBool = true;}
              if(currentState === states.pickingWalls){
                if(event){
                  for (var i = 0; i < pathfinder.allNodes.length; i++) {
                    if(pathfinder.allNodes[i].checkBounds()){
                      if(!pathfinder.allNodes[i].isWall){
                        pathfinder.allNodes[i].isWall = true;
                      }else if(pathfinder.allNodes[i].isWall){
                        pathfinder.allNodes[i].isWall = false;
                      }
                    }
                  };
                }
              }
              else if(currentState === states.pickingStartNode){
                if(event){
                  for (var i = 0; i < pathfinder.allNodes.length; i++) {
                    if(pathfinder.allNodes[i].checkBounds()){
                      if(!pathfinder.allNodes[i].startNode && !isStartNodeCreated && !pathfinder.allNodes[i].isWall){
                        pathfinder.allNodes[i].startNode = true;
                        pathfinder.startNode = pathfinder.allNodes[i];
                        pathfinder.checkingNode = pathfinder.startNode;
                        isStartNodeCreated = true;
                      }else if(pathfinder.allNodes[i].startNode){
                        pathfinder.allNodes[i].startNode = false;
                        pathfinder.startNode = null;
                        pathfinder.checkingNode = null;
                        isStartNodeCreated = false;
                      }
                    }
                  }
                };
              }
            else if(currentState === states.pickingTargetNode){
              if(event){
                for (var i = 0; i < pathfinder.allNodes.length; i++) {
                  if(pathfinder.allNodes[i].checkBounds()){
                    if(!pathfinder.allNodes[i].targetNode && !isTargetNodeCreated && !pathfinder.allNodes[i].isWall && !pathfinder.allNodes[i].startNode){
                      pathfinder.allNodes[i].targetNode = true;
                      pathfinder.targetNode = pathfinder.allNodes[i];
                      isTargetNodeCreated = true;
                    }else if(pathfinder.allNodes[i].targetNode){
                      pathfinder.allNodes[i].targetNode = false;
                      pathfinder.targetNode = null;
                      isTargetNodeCreated = false;
                    }
                  }
                };
              }
            }


            // };
          }

          document.onkeydown = function(event){
            if(event.keyCode == '13'){
              if(currentState === states.pickingWalls){
                currentState = states.pickingStartNode;
              }else if(currentState === states.pickingStartNode){
                currentState = states.pickingTargetNode;
              }else if(currentState === states.pickingTargetNode){
                currentState = states.findPath;
                pathfinder.CacluateHueristics();
                startPathFinding = true;
              }
            }
          }

        setTimeout(function() {
            var startTime = (new Date()).getTime();
            animate(canvas, context,startTime);
          }, 1000);
      </script>
</body> 